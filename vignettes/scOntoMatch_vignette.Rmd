---
title: "scOntoMatch_vignette"
author: "Yuyao Song"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::knitr}
  %\VignetteIndexEntry{scOntoMatch_vignette}
  %\usepackage[UTF-8]{inputenc}

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dpi=300)
```



## Installation

```{r install}

## install from source
if (!require("devtools")) install.packages("devtools")

#devtools::install_github("YY-SONG0718/scOntoMatch")
devtools::load_all("/Users/ysong/SOFTWARE/scOntoMatch/scOntoMatch")
#library(scOntoMatch)
library(ontologyIndex)
```

## Load data

Use the smartseq-2 lung dataset from Tabula Muris and Tabula Sapiens as example

```{r load data}
metadata = '../inst/extdata/metadata.tsv'

anno_col = 'cell_ontology_class'
onto_id_col = 'cell_ontology_id'

obo_file = '../inst/extdata/cl-basic.obo'
propagate_relationships = c('is_a', 'part_of')
ont <- ontologyIndex::get_OBO(obo_file, propagate_relationships = propagate_relationships)
```


## Match ontology

### Trim the ontology tree per dataset

Merging descendant terms to existing ancestor terms in the datasets to get a minimum ontology representation
```{r load adata}

obj_list = getSeuratRds(metadata = metadata, sep = "\t")
head(obj_list$TM_lung@meta.data)
```
```{r ontoMultiMinimal}
obj_list_minimal = scOntoMatch::ontoMultiMinimal(obj_list = obj_list, ont = ont, anno_col = anno_col, onto_id_col = onto_id_col)
```   

We can see that some cell types in adata2 can not match to an ontology term. Consider manual re-annotate. Note that always check literature before manual curation.
```{r re-annotate}
obj_list$TS_lung@meta.data[[anno_col]] = as.character(obj_list$TS_lung@meta.data[[anno_col]])
obj_list$TM_lung@meta.data[[anno_col]] = as.character(obj_list$TM_lung@meta.data[[anno_col]])
## nk cell can certainly be matched
obj_list$TS_lung@meta.data[which(obj_list$TS_lung@meta.data[[anno_col]] == 'nk cell'), anno_col] = 'natural killer cell'

## there are type 1 and type 2 alveolar fibroblast which both belongs to fibroblast of lung

obj_list$TS_lung@meta.data[which(obj_list$TS_lung@meta.data[[anno_col]] == 'alveolar fibroblast'), anno_col] = 'fibroblast of lung'

## capillary aerocyte is a recently discovered new lung-specific cell type that is good to keep it
## Gillich, A., Zhang, F., Farmer, C.G. et al. Capillary cell-type specialization in the alveolus. Nature 586, 785â€“789 (2020). https://doi.org/10.1038/s41586-020-2822-7

```

Now we can trim again
```{r ontoMultiMinimal_new}
obj_list_minimal = scOntoMatch::ontoMultiMinimal(obj_list = obj_list, ont = ont, anno_col = anno_col, onto_id_col = onto_id_col)
```
### Ontology tree for individual dataset
before trimming
```{r plotOntoTree}


plotOntoTree(ont = ont, 
                          onts = names(getOntologyId(obj_list$TM_lung@meta.data[['cell_ontology_class']], ont = ont)), 
                          ont_query = names(getOntologyId(obj_list$TM_lung@meta.data[['cell_ontology_class']], ont = ont)),
                          plot_ancestors = TRUE,  roots = 'CL:0000548',
                          fontsize=25)
```

```{r plotOntoTree_two}


plotOntoTree(ont = ont, 
                          onts = names(getOntologyId(obj_list$TS_lung@meta.data[['cell_ontology_class']], ont = ont)), 
                          ont_query = names(getOntologyId(obj_list$TS_lung@meta.data[['cell_ontology_class']], ont = ont)),
                          plot_ancestors = TRUE,  roots = 'CL:0000548',
                          fontsize=25)
```


after trimming
```{r plotOntoTree_minimal}

plotOntoTree(ont = ont, 
                          onts = names(getOntologyId(obj_list_minimal$TM_lung@meta.data[['cell_ontology_base']], ont = ont)), 
                          ont_query = names(getOntologyId(obj_list_minimal$TM_lung@meta.data[['cell_ontology_base']], ont = ont)),
                          plot_ancestors = TRUE,  roots = 'CL:0000548',
                          fontsize=25)
```

```{r plotOntoTree_minimal_two}

plotOntoTree(ont = ont, 
                          onts = names(getOntologyId(obj_list_minimal$TS_lung@meta.data[['cell_ontology_base']], ont = ont)), 
                          ont_query = names(getOntologyId(obj_list_minimal$TS_lung@meta.data[['cell_ontology_base']], ont = ont)),
                          plot_ancestors = TRUE,  roots = 'CL:0000548',
                          fontsize=25)
```


### ontoMatch
The core action of `ontoMatch` is to map descendant terms in one dataset to existing ancestor terms in the other dataset reciprocally

```{r ontoMultiMatch}

## perform ontoMatch on the original tree

obj_list_matched = scOntoMatch::ontoMultiMatch(obj_list = obj_list_minimal, anno_col = 'cell_ontology_base', onto_id_col = onto_id_col, ont = ont)
```

```{r plotMatchedOntoTree}

plts = plotMatchedOntoTree(ont = ont, obj_list = obj_list_matched,
                                 anno_col = 'cell_ontology_mapped', 
                                 onto_id_col = onto_id_col,
                                 roots = 'CL:0000548', fontsize=25)
```
```{r}
plts[[1]]
```
```{r plotMatchedOntoTree_two}
plts[[2]]
```


## Utility functions

getOntologyId and getOntologyName

```{r getOntologyName}
getOntologyName(onto_id = c("CL:0000082"), ont = ont)

```

```{r getOntologyId}
getOntologyId(obj_list$TM_lung@meta.data[[anno_col]], ont = ont)

```

```{r sessionInfo}
sessionInfo()
```
