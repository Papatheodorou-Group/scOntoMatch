---
title: "scOntoMatch_vignette"
author: "Yuyao Song"
date: "03/05/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dpi=300)
```



## Installation

```{r}

## install from source
# install.packages("devtools")
library(devtools)
devtools::install_github("YY-SONG0718/scOntoMatch")
library(scOntoMatch)
library(ontologyIndex)
library(anndata)
```

## Load data

Use the smartseq-2 lung dataset from Tabula Muris and Tabula Sapiens as example

```{r}
adata1 = '../example_data/TM_Lung_smartseq2_raw.h5ad'
adata2 = '../example_data/TS_Lung_smartseq2_decontX.h5ad'
ad_one <- read_h5ad(adata1)
ad_two <- read_h5ad(adata2)

anno_col = 'cell_ontology_class'
onto_id_col = 'cell_ontology_id'

obo_file = '../example_data/cl-basic.obo'
propagate_relationships = c('is_a', 'part_of')
ont <- ontologyIndex::get_OBO(obo_file, propagate_relationships = propagate_relationships)
```


## Match ontology

### Trim the ontology tree per dataset

Merging descendant terms to existing ancestor terms in the dataset to get a minimum ontology representation
```{r}

ad_minimal = ontoMinimal(adata = ad_one, anno_col = anno_col, onto_id_col = onto_id_col, ont = ont)

```
```{r}

ad_two_minimal = ontoMinimal(adata = ad_two, anno_col = anno_col, onto_id_col = onto_id_col, ont = ont)

```

We can see that some cell types in adata2 can not match to an ontology term. Consider manual re-annotate. Note that always check literature before manual curation.
```{r}
ad_two$obs[[anno_col]] = as.character(ad_two$obs[[anno_col]])

## nk cell can certainly be matched
ad_two$obs[which(ad_two$obs[[anno_col]] == 'nk cell'), anno_col] = 'natural killer cell'

## there are type 1 and type 2 alveolar fibroblast which both belongs to fibroblast of lung

ad_two$obs[which(ad_two$obs[[anno_col]] == 'alveolar fibroblast'), anno_col] = 'fibroblast of lung'

## capillary aerocyte is a recently discovered new lung-specific cell type that is good to keep it
## Gillich, A., Zhang, F., Farmer, C.G. et al. Capillary cell-type specialization in the alveolus. Nature 586, 785â€“789 (2020). https://doi.org/10.1038/s41586-020-2822-7

```

Now we can trim again
```{r}
ad_two_minimal = ontoMinimal(adata = ad_two, anno_col = anno_col, onto_id_col = onto_id_col, ont = ont)

```
### Ontology tree for individual dataset
before trimming
```{r}


plotOntoTree(ont = ont, 
                          onts = names(getOntologyId(ad_minimal$obs[['cell_ontology_class']], ont = ont)), 
                          ont_query = names(getOntologyId(ad_minimal$obs[['cell_ontology_class']], ont = ont)),
                          plot_ancestors = TRUE,  roots = 'CL:0000548',
                          fontsize=25)
```

```{r}


plotOntoTree(ont = ont, 
                          onts = names(getOntologyId(ad_two_minimal$obs[['cell_ontology_class']], ont = ont)), 
                          ont_query = names(getOntologyId(ad_two_minimal$obs[['cell_ontology_class']], ont = ont)),
                          plot_ancestors = TRUE,  roots = 'CL:0000548',
                          fontsize=25)
```


after trimming
```{r}

plotOntoTree(ont = ont, 
                          onts = names(getOntologyId(ad_minimal$obs[['cell_ontology_base']], ont = ont)), 
                          ont_query = names(getOntologyId(ad_minimal$obs[['cell_ontology_base']], ont = ont)),
                          plot_ancestors = TRUE,  roots = 'CL:0000548',
                          fontsize=25)
```

```{r}

plotOntoTree(ont = ont, 
                          onts = names(getOntologyId(ad_two_minimal$obs[['cell_ontology_base']], ont = ont)), 
                          ont_query = names(getOntologyId(ad_two_minimal$obs[['cell_ontology_base']], ont = ont)),
                          plot_ancestors = TRUE,  roots = 'CL:0000548',
                          fontsize=25)
```


### ontoMatch
The core action of `ontoMatch` is to map descendant terms in one dataset to existing ancestor terms in the other dataset reciprocally

```{r}

## perform ontoMatch on the original tree

adatas = ontoMatch(adata1 = ad_one, adata2 = ad_two, anno_col = 'cell_ontology_class', onto_id_col = onto_id_col, ont = ont)
levels(factor(adatas[[1]]$obs$cell_type_mapped_ontology))
```
```{r}
adatas

```
```{r}

plts = plotMatchedOntoTree(ont = ont, 
                                 adatas = adatas,
                                 anno_col = 'cell_type_mapped_ontology', 
                                 roots = 'CL:0000548', fontsize=25)
```
```{r}
plts$adata1
```
```{r}
plts$adata2
```

### perform ontoMatch on the trimmed ontology

```{r}

anno_col_minimal = "cell_ontology_base"

adatas_minimal = ontoMatch(adata1 = ad_minimal, adata2 = ad_two_minimal, anno_col = anno_col_minimal, onto_id_col = onto_id_col, ont = ont)

```
```{r}
adatas_minimal

```

```{r}

plts_minimal = plotMatchedOntoTree(ont = ont, 
                                 adatas = adatas_minimal,
                                 anno_col = 'cell_type_mapped_ontology', 
                                 roots = 'CL:0000548', fontsize=25)
```
```{r}
plts_minimal$adata1
```
```{r}
plts_minimal$adata2
```

## Utility functions

getOntologyId and getOntologyName

```{r}
ont <- ontologyIndex::get_OBO(obo_file, propagate_relationships = c('is_a', 'part_of'))

getOntologyName(adatas[[1]]$obs[[onto_id_col]], ont = ont)

```

```{r}

getOntologyId(adatas[[2]]$obs[[anno_col]], ont = ont)

```

```{r}
sessionInfo()
```
